local NodeMarket = {}
local TechnicalIndicators = require("src.systems.technical_indicators")

local function clamp(x, a, b) return math.max(a, math.min(b, x)) end
local function gaussian(mean, variance)
    return math.sqrt(-2 * variance * math.log(math.random())) * 
           math.cos(2 * math.pi * math.random()) + mean
end

-- Apply time-based exponential decay to rolling volumes and then add value
local function applyRollingVolume(c, addValue, now)
  if not c or not c.liquidity then return end
  local liq = c.liquidity
  local last = liq.lastVolUpdate or now
  local dt = math.max(0, (now - last))
  -- Windows in seconds
  local w24 = 86400
  local w7 = 604800
  local w30 = 2592000
  -- Decay factors
  local d24 = math.exp(-dt / w24)
  local d7 = math.exp(-dt / w7)
  local d30 = math.exp(-dt / w30)
  liq.volume24h = (liq.volume24h or 0) * d24 + (addValue or 0)
  liq.volume7d = (liq.volume7d or 0) * d7 + (addValue or 0)
  liq.volume30d = (liq.volume30d or 0) * d30 + (addValue or 0)
  liq.lastVolUpdate = now
end

-- Seed history functionality has been removed

-- Return raw candles
function NodeMarket.getCandles(node)
  return node.candles or {}
end

-- Return aggregated candles by intervalSeconds (1s if nil/<=1)
function NodeMarket.getAggregatedCandles(node, intervalSeconds)
  if not node then return {} end
  local candles = node.candles
  if not candles or #candles == 0 then return {} end
  if not intervalSeconds or intervalSeconds <= 1 then return candles end
  return TechnicalIndicators.aggregateCandles(candles, intervalSeconds)
end

-- Return downsampled candles with simple caching keyed by symbol/interval/targetCount and last candle timestamp
function NodeMarket.getDownsampledCandles(node, intervalSeconds, targetCount)
  if not node then return {} end
  local agg = NodeMarket.getAggregatedCandles(node, intervalSeconds)
  if not targetCount or targetCount <= 0 then return agg end
  -- Return a stable time-anchored slice of the most recent aggregated candles.
  -- Avoid count-based regrouping which causes the first visible candle to shift.
  local n = #agg
  if n == 0 then return agg end
  local keep = math.min(n, targetCount + 256) -- small buffer for panning without regrouping
  local start = math.max(1, n - keep + 1)
  local slice = {}
  for i = start, n do slice[#slice+1] = agg[i] end
  return slice
end

-- Global candle aggregation width (seconds); fixed to 1s for consistent data
NodeMarket.candleWidth = 1.0
local MAX_CANDLES = 14400 -- up to 4 hours at 1s resolution

-- Global transaction history for all nodes
NodeMarket.globalTransactionHistory = {}
NodeMarket._candleCache = {}

-- Initialize the market with default nodes
function NodeMarket.init()
  if NodeMarket._inited then return end
  NodeMarket._inited = true
  NodeMarket.nodes = {}
  
  -- Initialize with some default nodes
  local nodes = {
    { symbol = "NOVA", name = "Nova Labs", basePrice = 100 },
    { symbol = "QUARK", name = "Quark Systems", basePrice = 150 },
    { symbol = "PHOTON", name = "PhotonX Industries", basePrice = 200 },
    { symbol = "VOLT", name = "VoltWorks", basePrice = 75 },
    { symbol = "NEBULA", name = "Nebula Capital", basePrice = 250 }
  }
  
  for _, node in ipairs(nodes) do
    NodeMarket.addNode(node.symbol, node.name, node.basePrice)
  end
end

-- Add a new node to the market
function NodeMarket.addNode(symbol, name, basePrice)
  local node = {
    symbol = symbol,
    name = name,
    price = basePrice,
    supply = 1000000,
    marketCap = basePrice * 1000000,
    dayHigh = basePrice,
    dayLow = basePrice,
    dayOpen = basePrice,
    dayVolume = 0,
    candles = {},
    lastCandleT = 0,
    liquidity = {
      volume24h = 0,
      volume7d = 0,
      volume30d = 0,
      lastVolUpdate = 0,
      orderBookDepth = 100000,
      bidAskSpread = 0.002,
      slippageFactor = 1.0,
      buyPressure = 0.5
    },
    garch = {
      sigma = 0.1,
      omega = 0.0001,
      alpha = 0.1,
      beta = 0.85
    },
    rsi = {
      value = 50,
      period = 14,
      avgGain = 0,
      avgLoss = 0,
      lastPrice = basePrice,
      warmupCount = 0
    },
    regime = {
      state = 0,  -- -1: bear, 0: neutral, 1: bull
      timeInRegime = 0,
      nextRegimeChange = 3600 + math.random(3600),
      volMultiplier = 1.0
    },
    trendChangeIn = 300 + math.random(600),
    nextOrderIn = 0,
    activityFactor = 0.8 + math.random() * 0.4  -- 0.8 to 1.2
  }
  
  table.insert(NodeMarket.nodes, node)
  return node
end

-- Update a single candle
function NodeMarket._updateCandle(node, price, vol, when)
  local t = when or (love.timer and love.timer.getTime() or os.time())
  local width = NodeMarket.candleWidth or 1.0
  local bucket = math.floor(t / width) * width
  
  if #node.candles == 0 or bucket > node.lastCandleT then
    -- Create new candle
    local newCandle = {
      t = bucket,
      o = price,
      h = price,
      l = price,
      c = price,
      v = vol or 0
    }
    table.insert(node.candles, newCandle)
    
    -- Remove old candles if we exceed max
    while #node.candles > MAX_CANDLES do
      table.remove(node.candles, 1)
    end
    
    node.lastCandleT = bucket
  else
    -- Update current candle
    local last = node.candles[#node.candles]
    if last then
      last.h = math.max(last.h, price)
      last.l = math.min(last.l, price)
      last.c = price
      last.v = last.v + (vol or 0)
    end
  end
end

-- Global state for market-wide factors
function NodeMarket._updateGlobalState(dt)
  NodeMarket.state = NodeMarket.state or { time = 0, sectors = 3 }
  local st = NodeMarket.state
  st.time = (st.time or 0) + dt
  
  -- Initialize sector data if needed
  st.sectors = st.sectors or 3
  st.sectorDrift = st.sectorDrift or {}
  st.sectorVol = st.sectorVol or {}
  
  -- Update global drift and volatility (mean-reverting)
  st.globalDrift = (st.globalDrift or 0) * 0.99 + (math.random() - 0.5) * 0.0002
  st.globalVol = 0.2 + math.sin(st.time * 0.0001) * 0.05  -- Slow cycle
  
  -- Update sector factors
  for i = 1, st.sectors do
    local sd = st.sectorDrift[i] or 0
    local sv = st.sectorVol[i] or 1.0
    st.sectorDrift[i] = sd * 0.99 + (math.random() - 0.5) * 0.0005
    st.sectorVol[i] = math.max(0.5, math.min(2.0, sv * (0.99 + math.random() * 0.02)))
  end
  
  -- Update activity cycle (~5 minutes)
  st.activityCycle = 1 + 0.3 * math.sin(st.time * 0.002)
  
  -- News events
  st.nextNewsIn = st.nextNewsIn or (120 + math.random(240))
  if st.nextNewsIn <= 0 then
    -- News event in progress
    st.newsRemaining = (st.newsRemaining or 0) - dt
    if st.newsRemaining <= 0 then
      -- News event ended
      st.globalVolBoost = 0
      st.liqStress = 0
      st.nextNewsIn = 120 + math.random(240)  -- Next news in 2-6 minutes
    end
  else
    -- Count down to next news event
    st.nextNewsIn = st.nextNewsIn - dt
    if st.nextNewsIn <= 0 then
      -- Trigger news event
      st.newsRemaining = 10 + math.random(20)  -- Lasts 10-30 seconds
      st.globalVolBoost = 0.5 + math.random()  -- 0.5x to 1.5x volatility
      st.liqStress = 0.2 + math.random() * 0.6  -- 0.2 to 0.8 liquidity stress
      
      -- Affect a random sector
      local sector = 1 + math.floor(math.random() * st.sectors)
      st.sectorVol[sector] = (st.sectorVol[sector] or 1.0) * (1.2 + math.random() * 0.6)
    end
  end
end

-- Main update function
function NodeMarket.update(dt)
  if not NodeMarket._inited then NodeMarket.init() end
  local now = love.timer and love.timer.getTime() or os.time()
  
  -- Update global state
  NodeMarket._updateGlobalState(dt)
  local st = NodeMarket.state or {}
  
  -- Update each node
  for _, node in ipairs(NodeMarket.nodes) do
    -- Update trend
    node.trendChangeIn = node.trendChangeIn - dt
    if node.trendChangeIn <= 0 then
      node.trendChangeIn = 300 + math.random(600)  -- 5-15 minutes between trend changes
      node.trendTarget = (math.random() * 2 - 1) * 0.1  -- -10% to +10% target
    end
    
    -- Update price based on GARCH model
    local timeStep = 1.0 / (252 * 24 * 60 * 60)  -- 1 second in trading years
    local epsilon = gaussian(0, 1)
    local sigma = node.garch.sigma
    local returnStep = epsilon * sigma * math.sqrt(timeStep)
    
    -- Apply global and sector factors
    local sector = (node.symbol:byte() % (st.sectors or 3)) + 1
    local sectorDrift = st.sectorDrift and st.sectorDrift[sector] or 0
    local sectorVol = st.sectorVol and st.sectorVol[sector] or 1.0
    local volScale = (1 + (st.globalVolBoost or 0)) * sectorVol
    
    -- Calculate price change
    local drift = (node.trendTarget or 0) * timeStep
    local priceChange = math.exp(drift + returnStep * volScale) - 1.0
    local newPrice = node.price * (1 + priceChange)
    
    -- Update GARCH model
    local sigma2 = node.garch.omega * timeStep + 
                  node.garch.alpha * (returnStep^2) + 
                  node.garch.beta * (sigma^2)
    node.garch.sigma = math.sqrt(math.max(1e-8, math.min(1.0, sigma2)))
    
    -- Update RSI
    local delta = newPrice - node.price
    local gain = delta > 0 and delta or 0
    local loss = delta < 0 and -delta or 0
    
    if node.rsi.warmupCount < node.rsi.period then
      node.rsi.warmupCount = node.rsi.warmupCount + 1
      node.rsi.avgGain = ((node.rsi.avgGain * (node.rsi.warmupCount - 1)) + gain) / node.rsi.warmupCount
      node.rsi.avgLoss = ((node.rsi.avgLoss * (node.rsi.warmupCount - 1)) + loss) / node.rsi.warmupCount
    else
      node.rsi.avgGain = (node.rsi.avgGain * (node.rsi.period - 1) + gain) / node.rsi.period
      node.rsi.avgLoss = (node.rsi.avgLoss * (node.rsi.period - 1) + loss) / node.rsi.period
    end
    
    local rs = (node.rsi.avgLoss > 1e-12) and (node.rsi.avgGain / node.rsi.avgLoss) or 100
    node.rsi.value = 100 - (100 / (1 + rs))
    node.rsi.lastPrice = newPrice
    
    -- Update price and market cap
    node.price = newPrice
    node.marketCap = node.price * node.supply
    
    -- Update daily stats
    node.dayHigh = math.max(node.dayHigh, node.price)
    node.dayLow = math.min(node.dayLow, node.price)
    
    -- Simulate trades
    node.nextOrderIn = node.nextOrderIn - dt
    if node.nextOrderIn <= 0 then
      local baseInterval = 1.0 / (node.activityFactor or 1.0)  -- More active nodes trade more frequently
      node.nextOrderIn = baseInterval * (0.5 + math.random())  -- 0.5x to 1.5x base interval
      
      -- Calculate order size based on activity factor and volatility
      local orderSize = math.random(50, 200) * (node.activityFactor or 1.0)
      if math.random() < 0.05 then  -- 5% chance of a larger trade
        orderSize = orderSize * (2 + math.random() * 3)  -- 2x-5x larger
      end
      
      -- Apply price impact
      local priceImpact = (orderSize / 1e6) * 0.01  -- 1% impact per million in volume
      local rsiEffect = (node.rsi.value - 50) / 50 * 0.01  # +1% to -1% based on RSI
      local newPrice = node.price * (1 + (math.random() * 2 - 1) * 0.001 + rsiEffect)
      
      -- Update volume and candles
      local tradeValue = orderSize * newPrice
      node.dayVolume = node.dayVolume + orderSize
      applyRollingVolume(node, tradeValue, now)
      NodeMarket._updateCandle(node, newPrice, orderSize, now)
      
      -- Record transaction
      table.insert(NodeMarket.globalTransactionHistory, {
        type = math.random() > 0.5 and "BUY" or "SELL",
        symbol = node.symbol,
        quantity = orderSize,
        price = newPrice,
        timestamp = now,
        isPlayerTrade = false
      })
    end
    
    -- Update candle even if no trade occurred
    NodeMarket._updateCandle(node, node.price, 0, now)
  end
end

-- Get market statistics
function NodeMarket.getMarketStats()
  local stats = {
    totalMarketCap = 0,
    totalVolume24h = 0,
    nodeCount = #(NodeMarket.nodes or {})
  }
  
  for _, node in ipairs(NodeMarket.nodes or {}) do
    stats.totalMarketCap = stats.totalMarketCap + (node.marketCap or 0)
    stats.totalVolume24h = stats.totalVolume24h + (node.liquidity.volume24h or 0)
  end
  
  return stats
end

-- Get node by symbol
function NodeMarket.getNode(symbol)
  for _, node in ipairs(NodeMarket.nodes or {}) do
    if node.symbol == symbol then
      return node
    end
  end
  return nil
end

-- Get all nodes
function NodeMarket.getNodes()
  if not NodeMarket._inited then NodeMarket.init() end
  return NodeMarket.nodes or {}
end

-- Get recent transactions
function NodeMarket.getRecentTransactions(count)
  count = count or 10
  local n = math.min(count, #NodeMarket.globalTransactionHistory)
  local result = {}
  for i = #NodeMarket.globalTransactionHistory, #NodeMarket.globalTransactionHistory - n + 1, -1 do
    if i > 0 then
      table.insert(result, NodeMarket.globalTransactionHistory[i])
    end
  end
  return result
end

return NodeMarket
